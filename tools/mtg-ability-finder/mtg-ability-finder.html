<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light">
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: dark)">
    <title data-i18n-key="title">MTG Ability Finder</title>
    <script>
        window.i18n = {
            lang: localStorage.getItem('selectedLanguage') || 'ko',
            translations: {},
            initPromise: null,
            _resolveInit: null,

            init() {
                this.initPromise = new Promise(resolve => { this._resolveInit = resolve; });
                (async () => {
                    try {
                        const response = await fetch('../../assets/i18n/language.json');
                        if (!response.ok) throw new Error('Network response was not ok');
                        const data = await response.json();
                        this.translations = data.translations;
                        this.apply();
                    } catch (error) {
                        console.error('Failed to load translations:', error);
                    } finally {
                        this._resolveInit();
                    }
                })();
            },
            
            t(key, replacements = {}) {
                const translation = this.translations['mtg-ability-finder']?.[key]?.[this.lang];
                if (!translation) return key;
                let result = translation;
                for (const placeholder in replacements) {
                    result = result.replace(`{${placeholder}}`, replacements[placeholder]);
                }
                return result;
            },
            
            apply() {
                document.querySelectorAll('[data-i18n-key]').forEach(el => {
                    el.textContent = this.t(el.dataset.i18nKey);
                });
                document.querySelectorAll('[data-i18n-key-placeholder]').forEach(el => {
                    el.placeholder = this.t(el.dataset.i18nKeyPlaceholder);
                });
                document.querySelectorAll('[data-i18n-key-title]').forEach(el => {
                    el.title = this.t(el.dataset.i18nKeyTitle);
                });
                document.querySelectorAll('[data-i18n-key-alt]').forEach(el => {
                    el.alt = this.t(el.dataset.i18nKeyAlt);
                });
            }
        };
        window.i18n.init();
    </script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body,html{height:100%;margin:0;padding:0;display:flex;flex-direction:column;background-color:#f4f4f4;font-family:system-ui,sans-serif}
        #searchSection{max-width:none;margin:0 auto;position:relative;padding:0.5rem;flex-shrink:0;flex-grow:0}
        #abilityInput{
            font-size:1.5rem;
            padding:1rem;
            height:4rem;
            width:clamp(200px, 92vw, 600px); /* í™”ë©´ ë„“ìœ¼ë©´ 1600pxê¹Œì§€, ì¢ìœ¼ë©´ 600px~ë·°í¬íŠ¸ 92% */
            margin:0 auto; /* ì¤‘ì•™ ì •ë ¬ */
            display:block;
        }
        #suggestionBox{background:#fff;border:1px solid #ccc;border-radius:.5rem;margin-top:4px;max-height:320px;overflow-y:auto;padding-left:0;position:absolute;width:100%;z-index:1000;list-style:none;box-shadow:0 4px 12px rgba(0,0,0,.15);display:none;top:calc(100% + 6px);left:0;right:0}
        #customSuggestions{background-color:#fff;border:1px solid #ccc;border-radius:.5rem;box-shadow:0 4px 12px rgba(0,0,0,.15);padding:.25rem;z-index:9999;position:absolute;width:100%;list-style:none;margin-top:6px;max-height:320px;overflow-y:auto}
        .suggestion-item{display:block;background-color:#f3f3f3;border-radius:.5rem;padding:.7rem 1rem;margin:.25rem 0;cursor:pointer;font-weight:500;white-space:nowrap;text-align:left;box-shadow:0 1px 2px rgba(0,0,0,.06);border:1px solid #ddd;transition:background-color .15s ease,font-size .15s ease;font-size:1rem}
        .suggestion-item.active,.suggestion-item:hover{background-color:#007bff;color:#fff}
        #scrollableContent{flex-grow:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding:0 1rem 1rem 1rem}
        #abilityList{display:flex;flex-wrap:wrap;gap:.5rem;justify-content:center;padding:1rem}
        .ability-badge{all:unset;display:inline-block;padding:.6rem 1rem;background-color:#e0e0e0;border-radius:1rem;cursor:pointer;font-weight:600;white-space:nowrap;text-align:center;box-shadow:0 2px 4px rgba(0,0,0,.1);border:1px solid #ccc;min-width:120px;text-transform:capitalize;flex:0 0 auto;box-sizing:border-box}
        .ability-badge:hover{background-color:silver;transform:scale(1.03)}
        #divider{margin:1rem 0 1rem 0;border-bottom:1px solid #ccc}
        #abilityDetails{display:none;margin-top:2rem;text-align:center;padding-bottom:20px}
        #resetBtn{margin-top:1.5rem}
        /* ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ í‘œì‹œì¤„ */
        #lastUpdateBar{margin-top:.5rem;font-size:.95rem;color:#6c757d}
        
        /* â¬‡ [ì¶”ê°€ëœ CSS] â¬‡ */
        .category-header {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            width: 100%; /* ì „ì²´ ë„ˆë¹„ ì°¨ì§€ */
            text-align: left; /* ì™¼ìª½ ì •ë ¬ */
            padding-left: 1rem; /* ì½˜í…ì¸  íŒ¨ë”©ê³¼ ë§ì¶¤ */
            border-bottom: 2px solid #eee; /* êµ¬ë¶„ì„  ì¶”ê°€ */
            padding-bottom: 0.25rem;
        }
        
        .badge-container {
            display: flex;
            flex-wrap: wrap;
            gap: .5rem;
            justify-content: center; /* ë°°ì§€ë“¤ì€ ì¤‘ì•™ ì •ë ¬ ìœ ì§€ */
            padding: 0; 
            width: 100%;
        }
        /* â¬† [ì¶”ê°€ëœ CSS] â¬† */

        :root{color-scheme:light}
        html,body{background-color:#ffffff !important;color:#000000 !important;-webkit-text-size-adjust:100%;text-size-adjust:100%}
        @media (prefers-color-scheme: dark){
            :root{color-scheme:light}
            html,body{background-color:#ffffff !important;color:#000000 !important}
        }
        img,video,canvas,svg,iframe{filter:none !important;mix-blend-mode:normal !important;background-color:transparent}
        .btn,.card,.modal,.dropdown-menu,.list-group,.form-control{background-color:#ffffff !important;color:#000000 !important}
        #modal-tool-iframe{color-scheme:light;background:#ffffff}
        *{forced-color-adjust:none}
        a,[class*="bi-"]{color:#0d6efd !important}
    </style>
</head>
<body>
    <div id="searchSection">
        <input type="text" id="abilityInput" class="form-control mb-1" data-i18n-key-placeholder="abilityInputPlaceholder" placeholder="Enter MTG ability keyword" oninput="filterAbilities()" autocomplete="off">
        <div id="lastUpdateBar" data-i18n-key="lastUpdatedPrefix">last updated : <span id="lastUpdateText" data-i18n-key="lastUpdatedDefault">SPM-2025-09-26</span></div>
    </div>

    <div id="scrollableContent">
        <div id="divider"></div>
        <div id="abilityList"></div>

        <div id="abilityDetails">
            <h2 id="selectedAbility"></h2>
            <p id="abilityText" class="mt-3"></p>
            <button class="btn btn-secondary" id="resetBtn" onclick="resetView()" data-i18n-key="backToListButton">ğŸ” Back to List</button>
        </div>
    </div>

    <script>
        // í˜ì´ì§€ ê¸°ë³¸ ìœ í‹¸
        function version(){ return "1.0.0"; }
        function printVersion(){ console.log(window.i18n.t("toolVersionPrefix") + version()); }
        printVersion();
    </script>

    <script>
        let abilityList = document.getElementById("abilityList"),
            abilityInput = document.getElementById("abilityInput"),
            abilityDetails = document.getElementById("abilityDetails"),
            selectedAbility = document.getElementById("selectedAbility"),
            abilityText = document.getElementById("abilityText"),
            scrollableContent = document.getElementById("scrollableContent"),
            lastUpdateText = document.getElementById("lastUpdateText"),
            suggestionBox = document.createElement("ul");

        suggestionBox.id = "customSuggestions";
        suggestionBox.style.position = "absolute";
        suggestionBox.style.display = "none";
        abilityInput.parentNode.style.position = "relative";
        abilityInput.parentNode.appendChild(suggestionBox);

        let abilities = {}; // ë³‘í•© ë°ì´í„°(History ì œì™¸) - ê²€ìƒ‰ ë° ìƒì„¸ë³´ê¸°ë¥¼ ìœ„í•´ ì—¬ì „íˆ í•„ìš”

        // --- â¬‡ [ì‹ ê·œ] í—¬í¼ í•¨ìˆ˜ â¬‡ ---

        /**
         * ê°œë³„ ëŠ¥ë ¥ ë°°ì§€(ë±ƒì§€) ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
         * @param {string} name - ëŠ¥ë ¥ì˜ ì´ë¦„.
         * @returns {HTMLElement} ë°°ì§€ ì—˜ë¦¬ë¨¼íŠ¸.
         */
        function createBadge(name) {
            const chip = document.createElement("div");
            chip.className = "ability-badge";
            chip.innerText = name;
            chip.onclick = () => showAbility(name);
            return chip;
        }

        /**
         * ì¹´í…Œê³ ë¦¬ ì„¹ì…˜ ì „ì²´(í—¤ë” + ë°°ì§€ ì»¨í…Œì´ë„ˆ)ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
         * @param {string} title - ì¹´í…Œê³ ë¦¬ ì œëª©.
         * @param {object|Array} items - ë°°ì§€ë¡œ ë§Œë“¤ ì•„ì´í…œ (ê°ì²´ í‚¤ ë˜ëŠ” ë°°ì—´ ìš”ì†Œ).
         * @param {boolean} [isArray=false] - itemsê°€ ë°°ì—´ì¸ì§€ ì—¬ë¶€.
         * @returns {HTMLElement|null} ì™„ì„±ëœ ì„¹ì…˜ ì—˜ë¦¬ë¨¼íŠ¸ ë˜ëŠ” ì•„ì´í…œì´ ì—†ìœ¼ë©´ null.
         */
        function createCategorySection(title, items, isArray = false) {
            const hasItems = items && (isArray ? items.length > 0 : Object.keys(items).length > 0);
            if (!hasItems) {
                return null; // ë¹ˆ ì„¹ì…˜ì€ ìƒì„±í•˜ì§€ ì•ŠìŒ
            }

            const section = document.createElement("div");
            section.style.width = "100%"; // ì„¹ì…˜ì´ ì „ì²´ ë„ˆë¹„ë¥¼ ì°¨ì§€í•˜ë„ë¡ ì„¤ì •
            
            const header = document.createElement("h3");
            header.className = "category-header";
            header.innerText = title;
            section.appendChild(header);

            const container = document.createElement("div");
            container.className = "badge-container";
            
            // ì•„ì´í…œ í‚¤(ì´ë¦„)ë¥¼ ê°€ì ¸ì™€ ì •ë ¬í•œ í›„ ë°°ì§€ ìƒì„±
            const keys = isArray ? items.map(item => item.toLowerCase()) : Object.keys(items);
            keys.sort().forEach(name => {
                container.appendChild(createBadge(name));
            });
            
            section.appendChild(container);
            return section;
        }

        // --- â¬† [ì‹ ê·œ] í—¬í¼ í•¨ìˆ˜ â¬† ---

        // --- â¬‡ [ìˆ˜ì •] ì¹´í…Œê³ ë¦¬ë³„ ë Œë”ë§ í•¨ìˆ˜ â¬‡ ---

        function renderAbilityList(){
            abilityList.innerHTML = ""; // ëª©ë¡ ë¹„ìš°ê¸°
            
            // mtgDataê°€ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸
            if (!window.mtgData || !window.mtgData.abilities) {
                console.warn(window.i18n.t("mtgDataNotLoadedWarning"));
                return; 
            }

            const data = window.mtgData;

            // ê¸°ë³¸ ì¹´í…Œê³ ë¦¬ ì •ì˜
            const categories = [
                { title: window.i18n.t("categoryEvergreen"), data: data.evergreen },
                { title: window.i18n.t("categoryArenaOnly"), data: data.arena },
                { title: window.i18n.t("categoryDeckbuilding"), data: data.deckbuilding },
                { title: window.i18n.t("categorySpecialTokens"), data: data.special_tokens },
                { title: window.i18n.t("categorySpecialCounters"), data: data.special_counters },
				{ title: window.i18n.t("categoryRoles"), data: data.roles },
                { title: window.i18n.t("categorySpecial"), data: data.special }
            ];

            // ë©”ì¸ 'abilities' ê°ì²´ë¥¼ íƒ€ì…ë³„ë¡œ ë¶„ë¦¬
            const keywordAbilities = {};
            const keywordActions = {};
            const abilityWords = {};

            if (data.abilities) {
                for (const key in data.abilities) {
                    const item = data.abilities[key];
                    if (item.type === "keywordAbility") {
                        keywordAbilities[key] = item;
                    } else if (item.type === "keywordAction") {
                        keywordActions[key] = item;
                    } else if (item.type === "abilityWord") {
                        abilityWords[key] = item;
                    }
                }
            }
            
            // ë¶„ë¦¬ëœ ì¹´í…Œê³ ë¦¬ë¥¼ ëª©ë¡ì˜ ë‘ ë²ˆì§¸ ìœ„ì¹˜ì— ì‚½ì…
            categories.splice(1, 0, 
                { title: window.i18n.t("categoryKeywordAbilities"), data: keywordAbilities },
                { title: window.i18n.t("categoryKeywordActions"), data: keywordActions },
                { title: window.i18n.t("categoryAbilityWords"), data: abilityWords }
            );

            // ëª¨ë“  ì¹´í…Œê³ ë¦¬ ì„¹ì…˜ì„ ìƒì„±í•˜ê³  ì¶”ê°€
            categories.forEach(cat => {
                const section = createCategorySection(cat.title, cat.data, cat.isArray || false);
                if (section) { // nullì´ ì•„ë‹Œ(ë¹„ì–´ìˆì§€ ì•Šì€) ì„¹ì…˜ë§Œ ì¶”ê°€
                    abilityList.appendChild(section);
                }
            });
        }

        // --- â¬‡ [ì´í•˜ í•¨ìˆ˜ëŠ” ë³€ê²½ ì—†ìŒ] â¬‡ ---

        function formatText(text){
            return text.replace(/\{\{([^}]+)\}\}/g, (m, p1) => {
                const key = p1.toLowerCase();
                // íˆ´íŒ ì¡°íšŒëŠ” ë³‘í•©ëœ 'abilities' ê°ì²´ë¥¼ ì‚¬ìš© (ì •ìƒ)
                const ref = abilities[key] || (mtgData.abilities && mtgData.abilities[key]); 
                return (ref && ref.text)
                    ? `<span title="${ref.text}" style="text-decoration: underline dotted; cursor: help;">${p1}</span>`
                    : p1;
            });
        }

        function showAbility(name){
            // ìƒì„¸ ë³´ê¸°ëŠ” ë³‘í•©ëœ 'abilities' ê°ì²´ë¥¼ ì‚¬ìš© (ì •ìƒ)
            let entry = abilities[name]; 
            if(entry === undefined){
                console.warn(window.i18n.t("noInfoFoundWarningPrefix") + name + window.i18n.t("noInfoFoundWarningSuffix"));
                return;
            }
            if(typeof entry === "string") entry = { text: entry };

            selectedAbility.innerText = name;

            let badge = "";
            // ë°°ì§€ íƒ€ì… ë¶„ë¥˜ëŠ” ì›ë³¸ 'mtgData'ë¥¼ ì‚¬ìš© (ì •ìƒ)
            if(mtgData.evergreen?.[name]){
                badge = `<span class='badge bg-success ms-2'>${window.i18n.t("badgeEvergreen")}</span>`;
            } else if(mtgData.arena?.[name]){
                badge = `<span class='badge bg-warning text-dark ms-2'>${window.i18n.t("badgeArenaOnly")}</span>`;
            } else if(entry.type === "abilityWord"){
                badge = `<span class='badge bg-info ms-2'>${window.i18n.t("badgeAbilityWord")}</span>`;
            } else if(entry.type === "keywordAction"){
                badge = `<span class='badge bg-primary ms-2'>${window.i18n.t("badgeKeywordAction")}</span>`;
            } else if(entry.type === "keywordAbility"){
                badge = `<span class='badge bg-secondary ms-2'>${window.i18n.t("badgeKeywordAbility")}</span>`;
            } else if(entry.type === "deckbuilding"){
                badge = `<span class='badge bg-dark text-white ms-2'>${window.i18n.t("badgeDeckbuilding")}</span>`;
            } else if(entry.type === "role"){
                badge = `<span class='badge bg-dark text-white ms-2'>${window.i18n.t("badgeRole")}</span>`;
            } else if(mtgData.special?.[name]){
                badge = `<span class='badge bg-dark text-white ms-2'>${window.i18n.t("badgeSpecial")}</span>`;
            } else if(mtgData.special_counters?.[name]){
                badge = `<span class='badge bg-danger ms-2'>${window.i18n.t("badgeSpecialCounter")}</span>`;
            } else if(mtgData.special_tokens?.[name]){
                badge = `<span class='badge bg-info ms-2'>${window.i18n.t("badgeSpecialToken")}</span>`;
            }

            const img = entry.image ? `<br><img src="${entry.image}" style="max-width: 200px; margin-top: 1rem;" />` : "";
            abilityText.innerHTML = formatText(`<p>${entry.text}</p>` + badge + img);

            abilityList.style.display = "none";
            abilityDetails.style.display = "block";
            suggestionBox.style.display = "none";
            scrollableContent.scrollTop = 0;
        }

        function resetView(){
            abilityInput.value = "";
            abilityDetails.style.display = "none";
            abilityList.style.display = "flex";
            suggestionBox.style.display = "none";
            scrollableContent.scrollTop = 0;
        }

        function adjustContentHeight(){
            if(window.visualViewport){
                const headerH = document.getElementById("searchSection").offsetHeight;
                const h = window.visualViewport.height - headerH;
                scrollableContent.style.height = Math.max(0, h) + "px";
                if(document.activeElement === abilityInput){
                    setTimeout(() => {
                        abilityInput.scrollIntoView({behavior:"smooth", block:"start", inline:"nearest"});
                    }, 50);
                }
            }else{
                console.warn("Visual Viewport API not supported. Dynamic height adjustment may not work.");
            }
        }

        function positionSuggestionBox(){
            const a = abilityInput.getBoundingClientRect();
            const p = abilityInput.parentElement.getBoundingClientRect();
            const top = a.bottom - p.top;
            suggestionBox.style.top = top + "px";
            suggestionBox.style.left = "0px";
            suggestionBox.style.right = "0px"; 
            suggestionBox.style.width = "100%";
        }

        function filterAbilities(){
            const q = abilityInput.value.toLowerCase();
            suggestionBox.innerHTML = "";

            if(q === ""){
                suggestionBox.style.display = "none";
                return;
            }

            // ê²€ìƒ‰ì€ ë³‘í•©ëœ 'abilities' ê°ì²´ë¥¼ ì‚¬ìš© (ì •ìƒ)
            const matches = Object.keys(abilities).filter(n => n.toLowerCase().startsWith(q));
            const exact = matches.find(n => n.toLowerCase() === q);

            if(exact && matches.length === 1){
                showAbility(exact);
                suggestionBox.style.display = "none";
                return;
            }

            matches.forEach(n => {
                const li = document.createElement("li");
                li.className = "suggestion-item";
                li.innerText = n;
                li.onclick = () => {
                    abilityInput.value = n;
                    showAbility(n);
                    suggestionBox.style.display = "none";
                };
                suggestionBox.appendChild(li);
            });
            positionSuggestionBox();
            suggestionBox.style.display = "block";
        }

        window.mtgData = {};
        fetch("./assets/ability_data.json")
            .then(r => r.json())
            .then(data => {
                window.mtgData = data; // ì›ë³¸ ë°ì´í„° ì €ì¥ (ì¹´í…Œê³ ë¦¬ ë Œë”ë§ìš©)

                lastUpdateText.textContent = (data.meta && data.meta.version) ? data.meta.version : window.i18n.t("lastUpdatedDefault");

                // (ì¤‘ìš”) ê²€ìƒ‰ê³¼ ìƒì„¸ë³´ê¸°ë¥¼ ìœ„í•œ ë°ì´í„° ë³‘í•© ë¡œì§ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
                const merged = {
                    ...data.abilities,
                    ...data.evergreen,
                    ...data.arena,
                    ...data.special,
                    ...data.special_counters,
                    ...data.special_tokens
                };

                if(data.deckbuilding){
                    for(const k of Object.keys(data.deckbuilding)){
                        const key = k.toLowerCase();
                        merged[key] = {
                            text: data.deckbuilding[k],
                            type: "deckbuilding",
                            image: null
                        };
                    }
                }

                if (data.roles && typeof data.roles === "object" && !Array.isArray(data.roles)) {
					for (const [k, v] of Object.entries(data.roles)) {
						const key = k.toLowerCase();
						const text = (typeof v === "string") ? v : (v?.text || "");
						const image = (typeof v === "object" && v) ? (v.image ?? null) : null;

						merged[key] = {
							text: text,
							type: "role",
							image: image
						};
					}
				}

                abilities = merged; // ê²€ìƒ‰/ì¡°íšŒìš© ë³‘í•© ë°ì´í„° ì„¤ì •
                
                // [ìˆ˜ì •] ì¹´í…Œê³ ë¦¬ ëª©ë¡ ë Œë”ë§ í•¨ìˆ˜ í˜¸ì¶œ
                renderAbilityList(); 
                
                adjustContentHeight();
            });

        if(window.visualViewport){
            window.visualViewport.addEventListener("resize", adjustContentHeight);
            window.visualViewport.addEventListener("scroll", adjustContentHeight);
        }else{
            window.addEventListener("resize", adjustContentHeight);
        }
        document.addEventListener("DOMContentLoaded", adjustContentHeight);

        abilityInput.addEventListener("keydown", function(e){
            const items = suggestionBox.querySelectorAll("li");
            let idx = Array.from(items).findIndex(el => el.classList.contains("selected"));

            if(e.key === "ArrowDown"){
                if(items.length > 0){
                    e.preventDefault();
                    if(idx >= 0) items[idx].classList.remove("selected");
                    idx = (idx + 1) % items.length;
                    items[idx].classList.add("selected");
                    items[idx].scrollIntoView({behavior:"smooth", block:"nearest"});
                }
            }else if(e.key === "ArrowUp"){
                if(items.length > 0){
                    e.preventDefault();
                    if(idx >= 0) items[idx].classList.remove("selected");
                    idx = (idx - 1 + items.length) % items.length;
                    items[idx].classList.add("selected");
                    items[idx].scrollIntoView({behavior:"smooth", block:"nearest"});
                }
            }else if(e.key === "Enter"){
                if(idx >= 0){
                    e.preventDefault();
                    items[idx].click();
                }else{
                    const q = abilityInput.value.toLowerCase();
                    // Enterí‚¤ ì¡°íšŒëŠ” ë³‘í•©ëœ 'abilities' ê°ì²´ ì‚¬ìš© (ì •ìƒ)
                    const exact = Object.keys(abilities).filter(n => n.toLowerCase() === q);
                    if(exact.length === 1){
                        showAbility(exact[0]);
                        suggestionBox.style.display = "none";
                    }
                }
            }
        });
    </script>
</body>
</html>