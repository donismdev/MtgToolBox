<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>MTG Ability Finder</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
	<style>
		body {
			padding: 2rem;
			background-color: #f4f4f4;
			font-family: system-ui, sans-serif;
		}
		#searchSection {
			max-width: 800px;
			margin: 0 auto;
			position: relative;
		}
		#abilityInput {
			font-size: 1.5rem;
			padding: 1rem;
			height: 4rem;
		}
		#suggestionBox {
			background: white;
			border: 1px solid #ccc;
			border-radius: 0.5rem;
			margin-top: 4px;
			max-height: 200px;
			overflow-y: auto;
			padding-left: 0;
			position: absolute;
			width: 100%;
			z-index: 1000;
			list-style: none;
		}
		.suggestion-item {
			padding: 0.6rem 1rem;
			cursor: pointer;
		}
		.suggestion-item:hover,
		.suggestion-item.active {
			background-color: #007bff;
			color: white;
		}
		#abilityList {
			margin-top: 2rem;
			display: flex;
			flex-wrap: wrap;
			gap: 0.5rem;
			justify-content: center;
		}
		.ability-badge {
			padding: 0.6rem 1rem;
			background-color: #e0e0e0;
			border-radius: 1rem;
			cursor: pointer;
			font-weight: 500;
			transition: background-color 0.2s;
		}
		.ability-badge:hover {
			background-color: #c0c0c0;
		}
		#divider {
			margin: 3rem 0 1rem 0;
			border-bottom: 2px solid #bbb;
		}
		#abilityDetails {
			display: none;
			margin-top: 2rem;
			text-align: center;
		}
		#resetBtn {
			margin-top: 1.5rem;
		}
	</style>
</head>
<body>
<div id="searchSection">
	<input type="text" id="abilityInput" class="form-control mb-1" placeholder="Enter MTG ability keyword" oninput="filterAbilities()" autocomplete="off" />
	<div id="divider"></div>
	<div id="abilityList"></div>
	<div id="abilityDetails">
		<h2 id="selectedAbility"></h2>
		<p id="abilityText" class="mt-3"></p>
		<button class="btn btn-secondary" id="resetBtn" onclick="resetView()">Reset</button>
	</div>
</div>

<script>
const abilityList = document.getElementById("abilityList");
const abilityInput = document.getElementById("abilityInput");
const abilityDetails = document.getElementById("abilityDetails");
const selectedAbility = document.getElementById("selectedAbility");
const abilityText = document.getElementById("abilityText");

const suggestionBox = document.createElement("ul");
suggestionBox.id = "customSuggestions";
suggestionBox.style.position = "absolute";
suggestionBox.style.top = "100%";
suggestionBox.style.left = "0";
suggestionBox.style.right = "0";
suggestionBox.style.zIndex = "1000";
suggestionBox.style.listStyle = "none";
suggestionBox.style.margin = "0";
suggestionBox.style.padding = "0";
suggestionBox.style.backgroundColor = "#fff";
suggestionBox.style.border = "1px solid #ccc";
suggestionBox.style.borderTop = "none";
suggestionBox.style.maxHeight = "200px";
suggestionBox.style.overflowY = "auto";
suggestionBox.style.boxShadow = "0px 4px 6px rgba(0, 0, 0, 0.1)";
suggestionBox.style.display = "none";

abilityInput.parentNode.style.position = "relative";
abilityInput.parentNode.appendChild(suggestionBox);

let abilities = {};
window.mtgData = {};

fetch('abilities/ability_data.json')
	.then(res => res.json())
	.then(data => {
		window.mtgData = data;
		abilities = {
			...data.abilities,
			...data.evergreen,
			...data.arena,
			...data.special
		};
		renderAbilityList();
	});

function renderAbilityList() {
	abilityList.innerHTML = "";
	Object.keys(abilities).forEach(name => {
		const badge = document.createElement("div");
		badge.className = "ability-badge";
		badge.innerText = name;
		badge.onclick = () => showAbility(name);
		abilityList.appendChild(badge);
	});
}

function formatText(text) {
	return text.replace(/\{\{([^}]+)\}\}/g, (match, p1) => {
		const key = p1.toLowerCase();
		const ref = abilities[key] || mtgData.abilities?.[key];
		return ref && ref.text ? `<span title="${ref.text}" style="text-decoration: underline dotted; cursor: help;">${p1}</span>` : p1;
	});
}

function showAbility(name) {
	let info = abilities[name];

	// ❗ info 자체가 없는 경우
	if (info === undefined) {
		console.warn(`No info found for "${name}"`);
		return;
	}

	// ✅ string이면 객체로 변환
	if (typeof info === "string") {
		info = { text: info };
	}

	selectedAbility.innerText = name;

	let label = "";
	if (mtgData.evergreen?.[name]) {
		label = `<span class='badge bg-success ms-2'>Evergreen</span>`;
	} else if (mtgData.arena?.[name]) {
		label = `<span class='badge bg-warning text-dark ms-2'>Arena-only</span>`;
	} else if (info.type === "abilityWord") {
		label = `<span class='badge bg-info ms-2'>Ability Word</span>`;
	} else if (info.type === "keywordAction") {
		label = `<span class='badge bg-primary ms-2'>Keyword Action</span>`;
	} else if (info.type === "keywordAbility") {
		label = `<span class='badge bg-secondary ms-2'>Keyword Ability</span>`;
	} else if (mtgData.special?.[name]) {
		label = `<span class='badge bg-dark text-white ms-2'>Special</span>`;
	}

	abilityText.innerHTML = formatText(`<p>${info.text}</p>` + label +
		(info.image ? `<br><img src="${info.image}" style="max-width: 200px; margin-top: 1rem;" />` : "")
	);
	abilityList.style.display = "none";
	abilityDetails.style.display = "block";
	suggestionBox.style.display = "none";
}

function resetView() {
	abilityInput.value = "";
	abilityDetails.style.display = "none";
	abilityList.style.display = "flex";
	suggestionBox.style.display = "none";
}

abilityInput.addEventListener("keydown", function (e) {
	const items = suggestionBox.querySelectorAll("li");
	let index = Array.from(items).findIndex(item => item.classList.contains("selected"));

	if (e.key === "ArrowDown") {
		if (items.length > 0) {
			e.preventDefault();
			if (index >= 0) items[index].classList.remove("selected");
			index = (index + 1) % items.length;
			items[index].classList.add("selected");
		}
	} else if (e.key === "ArrowUp") {
		if (items.length > 0) {
			e.preventDefault();
			if (index >= 0) items[index].classList.remove("selected");
			index = (index - 1 + items.length) % items.length;
			items[index].classList.add("selected");
		}
	} else if (e.key === "Enter") {
		if (index >= 0) {
			e.preventDefault();
			items[index].click();
		} else {
			const query = abilityInput.value.toLowerCase();
			const matched = Object.keys(abilities).filter(name => name.toLowerCase() === query);
			if (matched.length === 1) {
				showAbility(matched[0]);
				suggestionBox.style.display = "none";
			}
		}
	}
});

function filterAbilities() {
	const query = abilityInput.value.toLowerCase();
	suggestionBox.innerHTML = "";

	if (query === "") {
		suggestionBox.style.display = "none";
		return;
	}

	const matched = Object.keys(abilities).filter(name => name.toLowerCase().startsWith(query));
	const exactMatch = matched.find(name => name.toLowerCase() === query);

	// ✅ 정확히 1개일 때만 자동 선택
	if (exactMatch && matched.length === 1) {
		showAbility(exactMatch);
		suggestionBox.style.display = "none";
		return;
	}

	matched.forEach(name => {
		const li = document.createElement("li");
		li.innerText = name;
		li.style.padding = "8px 12px";
		li.style.cursor = "pointer";
		li.onmouseover = () => li.classList.add("selected");
		li.onmouseout = () => li.classList.remove("selected");
		li.onclick = () => {
			abilityInput.value = name;
			showAbility(name);
			suggestionBox.style.display = "none";
		};
		suggestionBox.appendChild(li);
	});

	positionSuggestionBox();
	suggestionBox.style.display = "block";
}

function positionSuggestionBox() {
	const inputRect = abilityInput.getBoundingClientRect();
	const parentRect = abilityInput.parentElement.getBoundingClientRect();
	const offsetTop = inputRect.bottom - parentRect.top;

	suggestionBox.style.top = `${offsetTop}px`;
}
</script>

</body>
</html>
