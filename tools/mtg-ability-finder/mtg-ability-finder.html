<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<meta name="color-scheme" content="light">
	<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
	<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: dark)">
	<title>MTG Ability Finder</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<style>
		body,html{height:100%;margin:0;padding:0;display:flex;flex-direction:column;background-color:#f4f4f4;font-family:system-ui,sans-serif}
		/* ⬇ 컨테이너 폭↑ */
		#searchSection{max-width:1100px;margin:0 auto;position:relative;padding:1rem;flex-shrink:0;flex-grow:0}
		#abilityInput{font-size:1.5rem;padding:1rem;height:4rem}
		/* ⬇ 자동완성 박스 넓게/가독성↑ */
		#suggestionBox{background:#fff;border:1px solid #ccc;border-radius:.5rem;margin-top:4px;max-height:320px;overflow-y:auto;padding-left:0;position:absolute;width:100%;z-index:1000;list-style:none;box-shadow:0 4px 12px rgba(0,0,0,.15);display:none;top:calc(100% + 6px);left:0;right:0}
		#customSuggestions{background-color:#fff;border:1px solid #ccc;border-radius:.5rem;box-shadow:0 4px 12px rgba(0,0,0,.15);padding:.25rem;z-index:9999;position:absolute;width:100%;list-style:none;margin-top:6px;max-height:320px;overflow-y:auto}
		.suggestion-item{display:block;background-color:#f3f3f3;border-radius:.5rem;padding:.7rem 1rem;margin:.25rem 0;cursor:pointer;font-weight:500;white-space:nowrap;text-align:left;box-shadow:0 1px 2px rgba(0,0,0,.06);border:1px solid #ddd;transition:background-color .15s ease,font-size .15s ease;font-size:1rem}
		.suggestion-item.active,.suggestion-item:hover{background-color:#007bff;color:#fff}
		#scrollableContent{flex-grow:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding:0 1rem 1rem 1rem}
		#abilityList{display:flex;flex-wrap:wrap;gap:.5rem;justify-content:center;padding:1rem}
		.ability-badge{all:unset;display:inline-block;padding:.6rem 1rem;background-color:#e0e0e0;border-radius:1rem;cursor:pointer;font-weight:600;white-space:nowrap;text-align:center;box-shadow:0 2px 4px rgba(0,0,0,.1);border:1px solid #ccc;min-width:120px;text-transform:capitalize;flex:0 0 auto;box-sizing:border-box}
		.ability-badge:hover{background-color:silver;transform:scale(1.03)}
		#divider{margin:1rem 0 1rem 0;border-bottom:1px solid #ccc}
		#abilityDetails{display:none;margin-top:2rem;text-align:center;padding-bottom:20px}
		#resetBtn{margin-top:1.5rem}
		/* 마지막 업데이트 표시줄 */
		#lastUpdateBar{margin-top:.5rem;font-size:.95rem;color:#6c757d}
		:root{color-scheme:light}
		html,body{background-color:#ffffff !important;color:#000000 !important;-webkit-text-size-adjust:100%;text-size-adjust:100%}
		@media (prefers-color-scheme: dark){
			:root{color-scheme:light}
			html,body{background-color:#ffffff !important;color:#000000 !important}
		}
		img,video,canvas,svg,iframe{filter:none !important;mix-blend-mode:normal !important;background-color:transparent}
		.btn,.card,.modal,.dropdown-menu,.list-group,.form-control{background-color:#ffffff !important;color:#000000 !important}
		#modal-tool-iframe{color-scheme:light;background:#ffffff}
		*{forced-color-adjust:none}
		a,[class*="bi-"]{color:#0d6efd !important}
	</style>
</head>
<body>
	<div id="searchSection">
		<input type="text" id="abilityInput" class="form-control mb-1" placeholder="Enter MTG ability keyword" oninput="filterAbilities()" autocomplete="off">
		<!-- ⬇ 마지막 업데이트 표시 (JSON의 meta.version 사용, 없으면 SPM-2025-09-26) -->
		<div id="lastUpdateBar">last updated : <span id="lastUpdateText">SPM-2025-09-26</span></div>
	</div>

	<div id="scrollableContent">
		<div id="divider"></div>
		<div id="abilityList"></div>

		<div id="abilityDetails">
			<h2 id="selectedAbility"></h2>
			<p id="abilityText" class="mt-3"></p>
			<button class="btn btn-secondary" id="resetBtn" onclick="resetView()">🔁 Back to List</button>
		</div>
	</div>

	<script>
		// 페이지 기본 유틸
		function version(){	return "1.0.0"; }
		function printVersion(){ console.log("도구 모음 버전: " + version()); }
		printVersion();
	</script>

	<script>
		let abilityList = document.getElementById("abilityList"),
			abilityInput = document.getElementById("abilityInput"),
			abilityDetails = document.getElementById("abilityDetails"),
			selectedAbility = document.getElementById("selectedAbility"),
			abilityText = document.getElementById("abilityText"),
			scrollableContent = document.getElementById("scrollableContent"),
			lastUpdateText = document.getElementById("lastUpdateText"),
			suggestionBox = document.createElement("ul");

		suggestionBox.id = "customSuggestions";
		suggestionBox.style.position = "absolute";
		suggestionBox.style.display = "none";
		abilityInput.parentNode.style.position = "relative";
		abilityInput.parentNode.appendChild(suggestionBox);

		let abilities = {}; // 병합 데이터(History 제외)

		function renderAbilityList(){
			abilityList.innerHTML = "";
			Object.keys(abilities).forEach(name => {
				const chip = document.createElement("div");
				chip.className = "ability-badge";
				chip.innerText = name;
				chip.onclick = () => showAbility(name);
				abilityList.appendChild(chip);
			});
		}

		function formatText(text){
			return text.replace(/\{\{([^}]+)\}\}/g, (m, p1) => {
				const key = p1.toLowerCase();
				const ref = abilities[key] || mtgData.abilities?.[key];
				return (ref && ref.text)
					? `<span title="${ref.text}" style="text-decoration: underline dotted; cursor: help;">${p1}</span>`
					: p1;
			});
		}

		function showAbility(name){
			let entry = abilities[name];
			if(entry === undefined){
				console.warn(`No info found for "${name}"`);
				return;
			}
			if(typeof entry === "string") entry = { text: entry };

			selectedAbility.innerText = name;

			let badge = "";
			if(mtgData.evergreen?.[name]){
				badge = "<span class='badge bg-success ms-2'>Evergreen</span>";
			}else if(mtgData.arena?.[name]){
				badge = "<span class='badge bg-warning text-dark ms-2'>Arena-only</span>";
			}else if(entry.type === "abilityWord"){
				badge = "<span class='badge bg-info ms-2'>Ability Word</span>";
			}else if(entry.type === "keywordAction"){
				badge = "<span class='badge bg-primary ms-2'>Keyword Action</span>";
			}else if(entry.type === "keywordAbility"){
				badge = "<span class='badge bg-secondary ms-2'>Keyword Ability</span>";
			}else if(entry.type === "deckbuilding"){
				badge = "<span class='badge bg-dark text-white ms-2'>Deckbuilding</span>";
			}else if(entry.type === "role"){
				badge = "<span class='badge bg-dark text-white ms-2'>Role</span>";
			}else if(mtgData.special?.[name]){
				badge = "<span class='badge bg-dark text-white ms-2'>Special</span>";
			}else if(mtgData.special_counters?.[name]){
				badge = "<span class='badge bg-danger ms-2'>Special Counter</span>";
			}else if(mtgData.special_tokens?.[name]){
				badge = "<span class='badge bg-info ms-2'>Special Token</span>";
			}

			const img = entry.image ? `<br><img src="${entry.image}" style="max-width: 200px; margin-top: 1rem;" />` : "";
			abilityText.innerHTML = formatText(`<p>${entry.text}</p>` + badge + img);

			abilityList.style.display = "none";
			abilityDetails.style.display = "block";
			suggestionBox.style.display = "none";
			scrollableContent.scrollTop = 0;
		}

		function resetView(){
			abilityInput.value = "";
			abilityDetails.style.display = "none";
			abilityList.style.display = "flex";
			suggestionBox.style.display = "none";
			scrollableContent.scrollTop = 0;
		}

		function adjustContentHeight(){
			if(window.visualViewport){
				const headerH = document.getElementById("searchSection").offsetHeight;
				const h = window.visualViewport.height - headerH;
				scrollableContent.style.height = Math.max(0, h) + "px";
				if(document.activeElement === abilityInput){
					setTimeout(() => {
						abilityInput.scrollIntoView({behavior:"smooth", block:"start", inline:"nearest"});
					}, 50);
				}
			}else{
				console.warn("Visual Viewport API not supported. Dynamic height adjustment may not work.");
			}
		}

		function positionSuggestionBox(){
			const a = abilityInput.getBoundingClientRect();
			const p = abilityInput.parentElement.getBoundingClientRect();
			const top = a.bottom - p.top;
			suggestionBox.style.top = top + "px";
			suggestionBox.style.left = "0px";
			suggestionBox.style.right = "0px"; // 부모 폭 100%로
			suggestionBox.style.width = "100%";
		}

		function filterAbilities(){
			const q = abilityInput.value.toLowerCase();
			suggestionBox.innerHTML = "";

			if(q === ""){
				suggestionBox.style.display = "none";
				return;
			}

			const matches = Object.keys(abilities).filter(n => n.toLowerCase().startsWith(q));
			const exact = matches.find(n => n.toLowerCase() === q);

			if(exact && matches.length === 1){
				showAbility(exact);
				suggestionBox.style.display = "none";
				return;
			}

			matches.forEach(n => {
				const li = document.createElement("li");
				li.className = "suggestion-item";
				li.innerText = n;
				li.onclick = () => {
					abilityInput.value = n;
					showAbility(n);
					suggestionBox.style.display = "none";
				};
				suggestionBox.appendChild(li);
			});
			positionSuggestionBox();
			suggestionBox.style.display = "block";
		}

		window.mtgData = {};
		fetch("./assets/ability_data.json")
			.then(r => r.json())
			.then(data => {
				window.mtgData = data;

				// 마지막 업데이트 표시: meta.version 있으면 사용, 없으면 기본값
				lastUpdateText.textContent = (data.meta && data.meta.version) ? data.meta.version : "SPM-2025-09-26";

				// 병합 (history 제외)
				const merged = {
					...data.abilities,
					...data.evergreen,
					...data.arena,
					...data.special,
					...data.special_counters,
					...data.special_tokens
				};

				// deckbuilding 섹션
				if(data.deckbuilding){
					for(const k of Object.keys(data.deckbuilding)){
						const key = k.toLowerCase();
						merged[key] = {
							text: data.deckbuilding[k],
							type: "deckbuilding",
							image: null
						};
					}
				}

				// roles 섹션
				if(Array.isArray(data.roles)){
					for(const r of data.roles){
						const key = r.toLowerCase();
						if(!merged[key]){
							merged[key] = {
								text: `${r} (Role — Role token subtype from WOE. Only one role per creature per controller.)`,
								type: "role",
								image: null
							};
						}
					}
				}

				abilities = merged;
				renderAbilityList();
				adjustContentHeight();
			});

		if(window.visualViewport){
			window.visualViewport.addEventListener("resize", adjustContentHeight);
			window.visualViewport.addEventListener("scroll", adjustContentHeight);
		}else{
			window.addEventListener("resize", adjustContentHeight);
		}
		document.addEventListener("DOMContentLoaded", adjustContentHeight);

		abilityInput.addEventListener("keydown", function(e){
			const items = suggestionBox.querySelectorAll("li");
			let idx = Array.from(items).findIndex(el => el.classList.contains("selected"));

			if(e.key === "ArrowDown"){
				if(items.length > 0){
					e.preventDefault();
					if(idx >= 0) items[idx].classList.remove("selected");
					idx = (idx + 1) % items.length;
					items[idx].classList.add("selected");
					items[idx].scrollIntoView({behavior:"smooth", block:"nearest"});
				}
			}else if(e.key === "ArrowUp"){
				if(items.length > 0){
					e.preventDefault();
					if(idx >= 0) items[idx].classList.remove("selected");
					idx = (idx - 1 + items.length) % items.length;
					items[idx].classList.add("selected");
					items[idx].scrollIntoView({behavior:"smooth", block:"nearest"});
				}
			}else if(e.key === "Enter"){
				if(idx >= 0){
					e.preventDefault();
					items[idx].click();
				}else{
					const q = abilityInput.value.toLowerCase();
					const exact = Object.keys(abilities).filter(n => n.toLowerCase() === q);
					if(exact.length === 1){
						showAbility(exact[0]);
						suggestionBox.style.display = "none";
					}
				}
			}
		});
	</script>
</body>
</html>
